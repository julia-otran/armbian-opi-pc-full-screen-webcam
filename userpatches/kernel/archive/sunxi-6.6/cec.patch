From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Thu, 15 Feb 2024 04:59:01 +0000
Subject: Prevent HDMI CEC response for BMD

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 drivers/media/cec/core/cec-adap.c | 4 ++++
 drivers/media/cec/core/cec-api.c  | 4 +++-
 include/media/cec.h               | 2 ++
 include/uapi/linux/cec.h          | 2 ++
 4 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/drivers/media/cec/core/cec-adap.c b/drivers/media/cec/core/cec-adap.c
index 09ca83c23329..a07ce24e11e9 100644
--- a/drivers/media/cec/core/cec-adap.c
+++ b/drivers/media/cec/core/cec-adap.c
@@ -1989,10 +1989,14 @@ static int cec_receive_notify(struct cec_adapter *adap, struct cec_msg *msg,
 	/* Allow drivers to process the message first */
 	if (adap->ops->received && !adap->devnode.unregistered &&
 	    adap->ops->received(adap, msg) != -ENOMSG)
 		return 0;
 
+	if (adap->prevent_reply && msg->msg[1] != CEC_MSG_REPORT_PHYSICAL_ADDR) {
+		goto skip_processing;
+	}
+
 	/*
 	 * REPORT_PHYSICAL_ADDR, CEC_MSG_USER_CONTROL_PRESSED and
 	 * CEC_MSG_USER_CONTROL_RELEASED messages always have to be
 	 * handled by the CEC core, even if the passthrough mode is on.
 	 * The others are just ignored if passthrough mode is on.
diff --git a/drivers/media/cec/core/cec-api.c b/drivers/media/cec/core/cec-api.c
index 67dc79ef1705..ceb8d9eb0b64 100644
--- a/drivers/media/cec/core/cec-api.c
+++ b/drivers/media/cec/core/cec-api.c
@@ -374,15 +374,17 @@ static long cec_s_mode(struct cec_adapter *adap, struct cec_fh *fh,
 	bool send_pin_event = false;
 	long err = 0;
 
 	if (copy_from_user(&mode, parg, sizeof(mode)))
 		return -EFAULT;
-	if (mode & ~(CEC_MODE_INITIATOR_MSK | CEC_MODE_FOLLOWER_MSK)) {
+	if (mode & ~(CEC_MODE_INITIATOR_MSK | CEC_MODE_FOLLOWER_MSK | CEC_MODE_PREVENT_REPLY)) {
 		dprintk(1, "%s: invalid mode bits set\n", __func__);
 		return -EINVAL;
 	}
 
+	adap->prevent_reply = mode & CEC_MODE_PREVENT_REPLY;
+
 	mode_initiator = mode & CEC_MODE_INITIATOR_MSK;
 	mode_follower = mode & CEC_MODE_FOLLOWER_MSK;
 
 	if (mode_initiator > CEC_MODE_EXCL_INITIATOR ||
 	    mode_follower > CEC_MODE_MONITOR_ALL) {
diff --git a/include/media/cec.h b/include/media/cec.h
index 9c007f83569a..9a7a269233ec 100644
--- a/include/media/cec.h
+++ b/include/media/cec.h
@@ -274,10 +274,12 @@ struct cec_adapter {
 	struct dentry *cec_dir;
 
 	u32 sequence;
 
 	char input_phys[32];
+
+	bool prevent_reply;
 };
 
 static inline void *cec_get_drvdata(const struct cec_adapter *adap)
 {
 	return adap->priv;
diff --git a/include/uapi/linux/cec.h b/include/uapi/linux/cec.h
index b8e071abaea5..415bcdae8e68 100644
--- a/include/uapi/linux/cec.h
+++ b/include/uapi/linux/cec.h
@@ -317,10 +317,12 @@ static inline int cec_is_unconfigured(__u16 log_addr_mask)
 #define CEC_MODE_MONITOR_PIN		(0xd << 4)
 #define CEC_MODE_MONITOR		(0xe << 4)
 #define CEC_MODE_MONITOR_ALL		(0xf << 4)
 #define CEC_MODE_FOLLOWER_MSK		0xf0
 
+#define CEC_MODE_PREVENT_REPLY		0x100
+
 /* Userspace has to configure the physical address */
 #define CEC_CAP_PHYS_ADDR	(1 << 0)
 /* Userspace has to configure the logical addresses */
 #define CEC_CAP_LOG_ADDRS	(1 << 1)
 /* Userspace can transmit messages (and thus become follower as well) */
-- 
Created with Armbian build tools https://github.com/armbian/build

